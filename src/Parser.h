#ifndef PARSER_H
#define PARSER_H

#include <vector>
#include "Lexer.h"
#include "AST.h"
#include <memory>

/**
 * The Parser class converts a sequence of tokens into an Abstract Syntax Tree (AST).
 * It processes 'let' and 'show' statements, as well as expressions with identifiers and numbers.
 */
class Parser {
public:
    /**
     * Initializes the parser with a vector of tokens.
     *
     * @param tokens - a vector of tokens generated by the Lexer
     */
    explicit Parser(const std::vector<Token>& tokens);

    /**
     * Parses the tokens into an AST and stores it in the provided vector.
     *
     * @param ast - pointer to a vector to store the AST nodes
     */
    void parse(std::vector<std::unique_ptr<ASTNode>> *ast);

private:
    const std::vector<Token>& tokens;  // Reference to the tokenized input
    size_t current;                    // Current position in the token stream

    /**
     * Parses a 'let' statement, expecting an identifier and an expression.
     *
     * @return an AST node representing the assignment
     */
    std::unique_ptr<ASTNode> parseLetStatement();

    /**
     * Parses a 'show' statement, expecting an identifier to be displayed.
     *
     * @return an AST node representing the print operation
     */
    std::unique_ptr<ASTNode> parseShowStatement();

    /**
     * Parses an expression, could include binary operations and literals.
     *
     * @return an AST node representing the expression
     */
    std::unique_ptr<ASTNode> expression();

    /**
     * Consumes a token of the specified type, advancing the parser position.
     *
     * If the token type does not match, it logs an error.
     * @param type - the expected type of the next token
     */
    void consume(TokenType type);

    /**
     * Checks if the parser has reached the end of the token stream.
     *
     * @return true if at the end of the tokens, false otherwise
     */
    [[nodiscard]] bool isAtEnd() const;
};

#endif // PARSER_H
